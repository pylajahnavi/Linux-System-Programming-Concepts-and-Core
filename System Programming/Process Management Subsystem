1.  Explain the concept of Process Creation in Operating System?
    It is a mechanism by operating system, from which it creates a new process from an existing process. i.e., Parent -> Child
    -> Parent request for process creation
       UNIX/LINUX: fork() system call is used.
       Windows: CreateProcess()
    -> Kernel allocates a new Process Control Block.
    -> Kernel allocates the memory for the new process.  Linux uses copy-on-write technique to avoid immediate copying the entire address space, whereas windows loads the executable into a fresh address space.
    -> Child inherits resources from parent process.
    -> Schedular adds the new process to the ready queue.
    -> Parent and child begin execution.

2. Differentiate between the fork() and exec() system calls.
   fork(): Creates a new process within an existing process, which results in process within another process i.e., Parent and Child Process.
   -> Both parent and child continue executing the same code after the fork.
   -> Returns: 0 to the child process , Child’s PID to the parent, 1 on failure.
   -> Child gets a copy of the parent’s memory (using copy‑on‑write).
   -> File descriptors are duplicated from parent's process control block
   exec(): Replaces the current process image with the new process image.
   -> The process ID  stays the same, but the program running inside it changes.
   -> The original code is completely replaced. Execution starts from the new program’s main().
   -> If the program fails then it returns -1
   -> Entire memory space is replaced.
   -> Open file descriptors may remain open unless marked close-on-exec.

3. Write a C program to demonstrate the use of fork() system call.
   #include<stdio.h>
   #include<unistd.h>
   void main(){
    int pid = fork();
    if(pid < 0)
       printf("Program fails");
    else if(pid == 0)
       printf("Child Process is running\n);
    else
       printf("Parent Process is running\n);
   }

4. What is the purpose of the wait() system call in process management? 
   Primary purpose of wait() system call is to make a parent process pause until one of its child processes finishes execution.
   Why it is needed?
   1) Prevents Zombie Processes
   -> When a child process terminates, it still keeps an entry in the process table (a zombie) until the parent collects its exit status.
   -> wait() allows the parent to retrieve the child’s exit status, removing the zombie entry.
   2) Ensures Proper Synchronization
   -> Without wait(), the parent might finish execution before the child, leading to unpredictable behavior.
   -> wait() ensures the parent waits for the child to complete before continuing.
   3) Returns Information About Child Termination.
   -> wait() provides the PID of the terminated child.

5. Describe the role of the exec() family of functions in process management. 
   Basically, exec() family of calls plays a cruical role in replcing the current process image with the new process image.
   -> Used after fork() system call
   -> does not create a new process as well as does not return on success.
   -> It also allows passing arugments and environment variables.
   -> It also enables program loading and context-switching.
   -> Because exec keeps the same PID:
         --Parent-child relationships remain intact.
         --The parent can still use  to collect the child’s exit status.

6. Write a C program to illustrate the use of the execvp() function. 
   #include <stdio.h>
   #include <unistd.h>
   #include <sys/types.h>
   #include <sys/wait.h>
   int main() {
    pid_t pid = fork();
    if (pid < 0) {
        perror("fork failed");
        return 1;
    }
    if (pid == 0) {
        // Child process
        char *args[] = {"ls", "-l", NULL};  // Command and arguments
        printf("Child: Executing ls -l using execvp()\n");
        execvp(args[0], args);
        // execvp() only returns if it fails
        perror("execvp failed");
        return 1;
    } 
    else {
        // Parent process
        wait(NULL);
        printf("Parent: Child process finished.\n");
    }
    return 0;
   }

7. How does the vfork() system call differ from fork()? 
   fork(): Creates a process within another process, i.e., creates a child process within the parent process
   -> On failure returns -1, on Succes returns 0 for child process, and returns greater than 0 if it a parent process.
   -> Child process gets seperate copy of parent's process address space.
   -> Parent process and child process both run concurrently.
   vfork(): Creates a process within another process similar to fork()
   -> But there is no copy or duplication of address space of parent memory.
   -> Parent and child have independent addresses.
   -> Parent process is suspended until the child calls exec()
   -> On failure returns -1, on Succes returns 0 for child process, and returns greater than 0 if it a parent process.
   -> There is a disadvantage that a child process might modify the data of parent process.

8. Discuss the significance of the getpid() and getppid() system calls. 
   getpid(): It returns the process identifier of calling process.
   -> Every process has unique process identifier.
   -> This helps the OS and other processes track, manage, and control running programs.
   getppid(): It returns the parent's process identifier of a calling process.
   -> This helps a process know which process created it.
   -> Child processes often need to communicate with or report back to their parent thus it helps in process synchronization and coordination.

9. Explain the concept of process termination in UNIX-like operating systems.
   A process in a UNIX-like system is an instance of a running program. Termination occurs when a process has finished its execution or is 
   explicitly stopped by itself or by another process. The operating system handles this carefully to ensure proper resource management and to 
   communicate completion status to other processes.
   Mechanisms of Process Termination
   1. Normal Termination: A process can terminate itself voluntarily by calling the exit() system call. When doing so, it provides an exit status 
  (an integer value) to indicate success (0) or failure (non-zero) of execution. The kernel records this exit status so that the parent process can 
  retrieve it using the wait() or waitpid() system calls.
  2. Signal-induced Termination: Processes can be terminated by signals sent by other processes or by the kernel. Common signals include:
  ->SIGKILL: Forces immediate termination, cannot be caught or ignored.
  ->SIGTERM: Requests graceful termination, which the process can handle and perform cleanup before exiting.
  ->SIGINT: Sent typically by a user pressing Ctrl+C in a terminal to interrupt a process.
  3. Error-induced Termination: If a process executes an illegal operation, such as dividing by zero or accessing invalid memory, the kernel will 
  terminate the process and may generate a core dump for debugging purposes.
   
10. Write a program in C to create a child process using fork() and print its PID. 
    #include<stdio.h>
    #include<unistd.h>
    #include<sys/types.h>
    void main()
     {
      int pid = fork();
      if(pid < 0)
      printf("Error in process creation\n");
      if(pid ==0){
      printf("Child Process is running with PID: %d abd PPID: %d\n", getpid(), getppid());
      }
      else{
      printf("Parent Process is running with PID: %d\n", getpid());
     }

11. Describe the process hierarchy in UNIX-like operating systems.
    1. Root Process:
    The hierarchy originates from the init process or systemd (for modern os) which is assigned PID 1. This process is created by kernal during system bootup
    and remains running throughout the system uptime. 
    2. Parent and Child Process:
    Every process has a parent process and may have zero or more child processes. When a process creates another process using the fork() system call, 
    the newly created process is the child, and the original process is the parent. The child process inherits certain attributes from the parent, 
    like environment variables and open file descriptors.
    3. Process Tree Structure:
    The hierarchy forms a tree-like structure, often visualized as a process tree, where the root init process sits at the top, 
    and all other processes are descendants. Commands like ps -ef --forest or pstree can be used to visualize this tree.
    4. Orphan and Zombie process: 
    Orphan processes are child processes whose parent has terminated. In UNIX, these processes are reassigned to the init/systemd process, ensuring proper cleanup.
    Zombie processes occur when a child has finished execution but still has an entry in the process table because the parent has not yet 
    read its exit status. init automatically reaps such processes if the parent fails to do so.
    5. Process IDs (PID) and Parent Process IDs (PPID):
    Each process is uniquely identified by a PID, and a PPID points to its parent. This relationship helps manage signals, 
    process termination, and resource cleanup in the hierarchy.
    6. Shell and User Processes:
    User-level processes typically descend from the shell process that the user invokes (bash, zsh, etc.). 
    These shell processes themselves are children of login processes like getty or session managers.
   
